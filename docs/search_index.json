[["index.html", "Introduccion Chapter 1 Introduccion", " Introduccion Salvador Garcia Chapter 1 Introduccion Este curso está diseñado como un curso introductorio al lenguaje de programación R. Se hace una exploración rápida de la filosofia detrás de R, así como paquetes más usados y use cases más comunes. En texto esta dividido en los siguientes capítulos: "],["motivación.html", "Chapter 2 Motivación 2.1 Image Recognition: Cats vs Dogs 2.2 Motivación Data Visualization", " Chapter 2 Motivación Durante este capítulo se exploran distintas aplicaciones de R 2.1 Image Recognition: Cats vs Dogs En 2013 se hosteó uno de los problemas más populares en la plataforma Kaggle. El problema consiste en dada un conjunto de fotos de entrenamiento, poder crear un modelo que permitiera clasificar correctamenta a Gatos de Perros. Actualmente este problema ya es algo fácil de resolver y es de conocimiento popular como lograr un buen resultado en este tipo de problemas de clasificación. El siguiente código está basado en el código original del usuario de Kaggle Tiago Marques. Si es un usuario que va iniciando en R, se recomienda tomar este capítulo como motivacional, ya que tiene el grado de complejidad es medio, no adecuado para usuarios que van iniciando en R. Un ejemplo de imagenes mostradas son: Básicamente consiste en 4 secciones: Cargar librerias y funciones auxiliares Dividir el conjunto inicial de datos en conjuntos de Train - Test Definir y entrenar el modelo en Keras Predecir para nuevas observaciones 2.1.1 1) Cargar librerias y funciones auxiliares 2.1.2 2) Train - Test Split 2.1.3 3) Definición y entrenamiento de modelo (Keras) 2.1.4 4) Predicción de nuevos datos 2.2 Motivación Data Visualization R tiene un framework para crear gráficas que (creo yo) es de los más versátiles para cosas estáticas. Este framework es llamado ggplot. Además de ese framework cuenta con otros como lattice o base, pero en general están en desuso. library(alluvial) library(ggalluvial) library(magrittr) data(vaccinations) cbPalette &lt;- c(&quot;#999999&quot;, &quot;#E69F00&quot;, &quot;#56B4E9&quot;, &quot;#009E73&quot;, &quot;#F0E442&quot;, &quot;#0072B2&quot;, &quot;#D55E00&quot;, &quot;#CC79A7&quot;) levels(vaccinations$response) &lt;- rev(levels(vaccinations$response)) vaccinations %&gt;% ggplot( aes(x = survey, fill = response, stratum = response, alluvium = subject, weight = freq)) + geom_flow() + geom_stratum(alpha = .8) + geom_text(stat = &quot;stratum&quot;, infer.label = TRUE, size = 2.5) + theme_bw() + theme(legend.position = &quot;none&quot;, panel.background = element_rect(fill = NA), panel.grid.major.y = element_line(size = 1), panel.grid.major.x = element_line(size = 0), panel.grid.minor = element_line(size = 0), axis.line = element_line(size = 0), panel.border = element_rect(size = 0)) + scale_fill_manual( values = c(cbPalette, &quot;#999999&quot;, &quot;#999999&quot;)) + theme(legend.position = &quot;none&quot;) + labs(title = &quot;Respuestas en encuestas de vacunación en tres puntos en el tiempo&quot;, x = &quot;encuesta&quot;, y = &quot;numero de personas&quot;) ## Warning: The parameter `infer.label` is deprecated. ## Use `aes(label = after_stat(stratum))`. Si notan, el texto para crear la grafíca es largo y parece dificil, pero con practica todos estos comandos se vuelven intuitivos. Para esta intro a visualización de datos, solamente veremos diferentes tipos de gráficas y en capitulos siguientes profundizaremos en creación de gráficas. Además veremos conceptos básicos de bases de datos. "],["introducción.html", "Chapter 3 Introducción 3.1 El lenguaje de programación R 3.2 Paquetes y librerias de R 3.3 Paradigma de R 3.4 Proyectos de R y Paths 3.5 Instalación de R 3.6 Instalación de Rstudio 3.7 Instalación de paquetes desde el CRAN. 3.8 Ejercicios de practica", " Chapter 3 Introducción 3.1 El lenguaje de programación R R es un lenguaje de programación con un enfoque al análisis estadístico. R es un software libre de código abierto. De esta manera se permite hacer profiling y debugging a profundidad. (¡E instalarlo y utilizarlo en cualquier lugar!) R es un software hecho a la medida; es decir, el usuario instala la paquetería necesaria a sus necesidades. 3.2 Paquetes y librerias de R La primer diferencia para entender R, es entender la diferencia entre paquete y libreria. Paquete es el grupo de codigos que descargamos de internet y libreria es un paquete que se encuentra instalado y listo para usar. La paquetería básica de R está basada en librerías en Fortran y C (lenguajes de programación low level), creando wrappers que hacen referencia a las funciones originales. Por ejemplo, al calcular distintas factorizaciones de matrices (LU, Chol, QR, SVD, Schur) son calculadas utilizando la librería de LAPACK. Algunas paqueterías requieren que el software este instalado en el sistema. Por ejemplo: la mayoría de paquetería para manipulación de imágenes (png, jpeg, svg). Esta paquetería está por default instalada en Windows y macOS la paquetería para simular MCMC (R2Jags, Rstan, R2OpenBUGS), Se tiene que instalar explícitamente en Windows y macOS, así como añadir a las respectivas variables de entorno 3.3 Paradigma de R ¿Es R un Lenguage orientado a objetos? R es considerado un lenguaje multiparadigma. Es decir, puede ser orientado a objetos o no, puede ser funcional o no, puede ser imperativo o no. Esta flexibilidad nace de la necesidad y la diversidad de usuarios. Por ejemplo, R tiene 3 sistemas distintos de programación orientada a objetos (más los heredados de otros lenguajes). ¿R vs Python? R y python son ambos lenguajes de alto nivel. Mucho se habla que Python es más eficiente que R (con varios papers realizando benchmarks), pero en la realidad ambos lenguajes presentan un performance mucho más bajo que lenguajes low level como C o C++. En mi opinión, si solo se requiere analizar datos, escribir scripts de automatización y modelar datos, R es la herramienta adecuada. Si se quiere tener cosas en productivo, Python es una herramienta adecuada. 3.4 Proyectos de R y Paths Un proyecto en Rstudio tiene amplias ventajas ya que permite dividir el trabajo en distintos contextos, cada uno con su propio directorio de trabajo, historial de ejecución y códigos. Para poder crear un proyecto se requiere tener instalado RStudio. Se pueden crear proyectos en un nuevo directorio, en un directorio existente o clonando un repositorio de Github. Para crear un nuevo proyecto, basta con dar click en Archivo -&gt; Nuevo proyecto y seguir las instrucciones que aparecen. Una vez creado, aparecerá en el directorio del proyecto un nuevo archivo con extensión .Rproj. Este archivo contiene distintas configuraciones del proyecto. Además de este archivo, se crea el directorio oculto .Rproj.user donde aparecen las configuraciones específicas del proyecto. Finalmente, en la parte superior derecha aparece el nombre del proyecto. Antes de profundizar en los proyectos, se explicarán brevemente los archivos: .Rprofile: Hace referencia a un archivo oculto que contiene código en R que se ejecuta justo al iniciar R. .Rdata: Contiene datos guardados del proyecto. .Rhistory: Contiene un historial de los comandos ejecutados. Adicional a esto, es necesario explicar el término directorio de trabajo. Los filesystem de Windows y macOS permiten ubicar un archivo o directorio a través de una ruta. Por ejemplo, en Windows las rutas son de la forma: C:\\Users\\usuario1\\proyectos\\curso_r En cambio, en macOS, los directorios son de la forma: /Users/usuario1/proyectos/curso_r Para no tener que escribir la ruta completa de un archivo, se define el directorio de trabajo. Por default, el directorio de trabajo es el mismo que la carpeta home del usuario, pero siempre es conveniente modificarlo. Para obtener el directorio de trabajo actual se utiliza la función getwd(), mientras que para modificarlo se utiliza la función setwd(). Una vez explicados estos términos, se puede profundizar un poco más acerca de las funcionalidades del proyecto. Una vez creado, se puede abrir y cerrar las veces que sea necesario, pero lo importante es que cada vez que se abra el proyecto, se llevarán a cabo los siguientes pasos: Se iniciará una nueva sesión de R. Por lo tanto, se tienen que cargar de nuevo las librerías (con library()) Se carga el código que se encuentra en el archivo .Rprofile Se cargan los datos almacenados en .Rdata Se carga la historia del código ejecutado obtenida del archivo .Rhistory El directorio de trabajo es configurado en la carpeta del proyecto actual Se abren los archivos que se estaban editando cuando se cerro el proyecto Se cargan otras configuraciones particulares del proyecto 3.5 Instalación de R Al instalar R, se instala la consola que permite la ejecución de código y funciones. Adicionalmente, se instalan las librerías core que permiten el correcto funcionamiento de R. Al iniciar una sesión de R, un subconjunto de las librerías core son cargadas automáticamente: Librería Descripción base Contiene funciones básicas que permiten funcionar a R como un lenguaje de programación: funciones aritméticas, input/output, etc compiler Permite la compilación del Byte Code en R. datasets Contiene una amplia variedad de datasets en R. graphics Contiene funciones para los gráficos base. grDevices Suplemento para el paquete graphics. Colores y fuentes. grid Suplemento para el paquete graphics. methods Permite definir métodos y clases para los objetos de R. parallel Permite cómputo en paralelo en R. splines Funciones y clases para splines. stats Funciones para cálculos estadísticos y generación de números aleatorios. stats4 Funciones estadísticas usando las clases S4. tcltk Permite el uso del lenguage para scripts TCL. tools Contiene funciones para manipular paquetes de R y su documentación. utils Contiene gran variedad de funciones utilitarias. Mientras que el otro subconjunto de librerías core necesitan ser cargadas explícitamente con la función library(). Para obtener una lista con estas librerías de click en este link. 3.6 Instalación de Rstudio Para aumentar la productividad al programar en R, es muy recomendable instalar RStudio. Rstudio es un IDE (Integrated Development Environment) que facilita (entre otras funcionalidades): Crear de scripts en un editor de texto Visualizar variables en el entorno actual Crear proyectos Autocompletar código Usar shortcuts Usar fácilmente un control de versiones como Git. Ver la historia de ejecución. 3.7 Instalación de paquetes desde el CRAN. Además de las librerías core de R, se pueden instalar nuevos paquetes desde el CRAN (Comprehensive R Archive Network) o bien, instalar paquetes en desarrollo desde Github. Cada paquete es una colección de funciones, datos y código compilado. Todas estas son agregados a la librería de funciones de R, pero no son cargadas en automático (de nuevo, se necesita usar la función library()). En resumen, se instala el paquete solamente una vez, pero se carga la librería cada vez que se abre una sesión nueva. El CRAN es un repositorio central que contiene todos los paquetes disponibles en R. El CRAN está replicado a través de espejos (mirrors) en todo el mundo, esto con el fin de brindar disponibilidad y baja latencia al descargar los paquetes. Para instalar un paquete desde el CRAN se tiene que usar la función: install_packages(\"nombre_paquete\"), usando comillas alrededor del nombre del paquete. Adicional al CRAN, hay usuarios que desarrollan paquetes y los hostean en Github, principalmente cuando son paquetes en desarrollo o versiones nuevas (algunas veces no estables). Para poder instalar paquetes desde github, se necesita la función install_github(\"nombre_paquete\") de la librería devtools. Una vez instalado el paquete, el conjunto de funciones, los datos y el código compilado son almacenados en una librería que no se carga automáticamente; por lo tanto, en caso de hacer referencia a una función del paquete se mostrará un error. Por esto, es muy importante que una vez instalado el paquete se utilice la función library(\"nombre_paquete\") cada vez que se inicie una sesión. (Imaginen que tienen 1000 paquetes instalados, es poco practico siempre poder acceder a todas las funciones de cada uno de los paquetes en todo momento. Por esto, solamente es recomendable solo cargar las librerías que se ocuparán en el proyecto a desarrollar.) 3.8 Ejercicios de practica 3.8.1 Ejercicio 1. R Projects &amp; Paths ———————————————– Conceptos básicos: Directorio de trabajo (PATH): Es donde se guardan por default los archivos y donde se leen por default. Path absoluto: especifica la ruta desde el root del sistema (por ejemplo: C:1.csv) Path relativo es relativo a la carpeta (por ejemplo: archivo1.csv) Al inicializar un proyecto, todo se usa a través de un path relativo getwd() # obtiene el path absoluto por default ## [1] &quot;/Users/sgarciago/Desktop/Repos/class_2020_R&quot; setwd(&quot;.&quot;) # permite hacer overwrite del path por default 3.8.2 Ejercicio 2. Installing &amp; loading packages ———————————— Conceptos básicos: paquete y libreria Para usar un paquete/libreria en R, son dos pasos: instalar el paquete y cargar libreria (install.packages() se corre solo una vez para instalar el paquete, library() se corre cada vez que se quiera usar la libreria) install.packages(&quot;crayon&quot;, repo=&quot;http://cran.rstudio.com/&quot;) ## ## The downloaded binary packages are in ## /var/folders/t4/6cs23xyn51b429l5x8q39fl80000gp/T//RtmpTKSPVj/downloaded_packages library(crayon) Para visualizar todos los paquetes se puede ocupar el panel derecho en la pestaña de packages o bien con la funcion: installed.packages() library(tidyverse) ## ── Attaching packages ─────────────────────────────────────── tidyverse 1.3.0 ── ## ✓ ggplot2 3.3.2 ✓ purrr 0.3.4 ## ✓ tibble 3.0.4 ✓ dplyr 1.0.2 ## ✓ tidyr 1.1.2 ✓ stringr 1.4.0 ## ✓ readr 1.4.0 ✓ forcats 0.5.0 ## ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ── ## x ggplot2::%+%() masks crayon::%+%() ## x dplyr::filter() masks stats::filter() ## x dplyr::lag() masks stats::lag() installed.packages() %&gt;% head() ## Package ## A3 &quot;A3&quot; ## abind &quot;abind&quot; ## alluvial &quot;alluvial&quot; ## AmesHousing &quot;AmesHousing&quot; ## AnomalyDetection &quot;AnomalyDetection&quot; ## anytime &quot;anytime&quot; ## LibPath ## A3 &quot;/Library/Frameworks/R.framework/Versions/4.0/Resources/library&quot; ## abind &quot;/Library/Frameworks/R.framework/Versions/4.0/Resources/library&quot; ## alluvial &quot;/Library/Frameworks/R.framework/Versions/4.0/Resources/library&quot; ## AmesHousing &quot;/Library/Frameworks/R.framework/Versions/4.0/Resources/library&quot; ## AnomalyDetection &quot;/Library/Frameworks/R.framework/Versions/4.0/Resources/library&quot; ## anytime &quot;/Library/Frameworks/R.framework/Versions/4.0/Resources/library&quot; ## Version Priority Depends ## A3 &quot;1.0.0&quot; NA &quot;R (&gt;= 2.15.0), xtable, pbapply&quot; ## abind &quot;1.4-5&quot; NA &quot;R (&gt;= 1.5.0)&quot; ## alluvial &quot;0.1-2&quot; NA NA ## AmesHousing &quot;0.0.4&quot; NA &quot;R (&gt;= 2.10)&quot; ## AnomalyDetection &quot;1.0&quot; NA &quot;R (&gt;= 2.10.0)&quot; ## anytime &quot;0.3.9&quot; NA &quot;R (&gt;= 3.2.0)&quot; ## Imports LinkingTo ## A3 NA NA ## abind &quot;methods, utils&quot; NA ## alluvial NA NA ## AmesHousing &quot;dplyr, magrittr&quot; NA ## AnomalyDetection &quot;ggplot2, stringr, lubridate&quot; NA ## anytime &quot;Rcpp (&gt;= 0.12.9)&quot; &quot;Rcpp (&gt;= 0.12.9), BH&quot; ## Suggests ## A3 &quot;randomForest, e1071&quot; ## abind NA ## alluvial &quot;devtools, testthat, reshape2, knitr, rmarkdown, dplyr&quot; ## AmesHousing &quot;covr&quot; ## AnomalyDetection &quot;testthat&quot; ## anytime &quot;tinytest (&gt;= 1.0.0), gettz&quot; ## Enhances License License_is_FOSS ## A3 NA &quot;GPL (&gt;= 2)&quot; NA ## abind NA &quot;LGPL (&gt;= 2)&quot; NA ## alluvial NA &quot;MIT + file LICENSE&quot; NA ## AmesHousing NA &quot;GPL-2&quot; NA ## AnomalyDetection NA &quot;GPL-3&quot; NA ## anytime NA &quot;GPL (&gt;= 2)&quot; NA ## License_restricts_use OS_type MD5sum NeedsCompilation Built ## A3 NA NA NA &quot;no&quot; &quot;4.0.2&quot; ## abind NA NA NA &quot;no&quot; &quot;4.0.2&quot; ## alluvial NA NA NA &quot;no&quot; &quot;4.0.2&quot; ## AmesHousing NA NA NA &quot;no&quot; &quot;4.0.2&quot; ## AnomalyDetection NA NA NA &quot;no&quot; &quot;4.0.2&quot; ## anytime NA NA NA &quot;yes&quot; &quot;4.0.2&quot; "],["estructura-de-datos-de-r.html", "Chapter 4 Estructura de datos de R 4.1 Ayuda y vignettes 4.2 Namespaces 4.3 Paquetería útil para el análisis de datos 4.4 Estructuras de datos en R 4.5 Funciones, condicionales e iteraciones: 4.6 Ejercicios de practica", " Chapter 4 Estructura de datos de R 4.1 Ayuda y vignettes Cada función de la paquetería instalada desde el CRAN contiene una sección de ayuda, donde se brinda la descripción de la función, los argumentos de entrada y salida y ejemplos de uso. Con el código: help(nombre_función) se accede a esta ayuda. Algunos paquetes contienen viñetas o vignettes que es una documentación más detallada del paquete. Para acceder a estas viñetas se utiliza el código: vignette(\"nombre_paquete\") Si se requiere información rápida de visualización, desarrollo de paquetes, conceptos básicos y avanzados de R, markdown, shiny, etc, los Cheat sheets de RStudio son una fuente fácil y rápida. Si se requiere mayor documentación acerca de R, estos libros son muy útiles: R for data science. Contiene documentación de la paquetería del tidyverse e información útil para manejo de datos. ggplot2: elegant graphics for data analysis. Contiene documentación de ggplot, una librería basada en el grammar of graphics para visualización Advanced R. contiene información a detalle de como funciona R. R packages: contiene información que permite la creación y publicación de paquetes en R. 4.2 Namespaces Como el nombre lo sugiere, un namespace es un espacio de nombres para las funciones. En la situación óptima, cada desarrollador de paquete no debería definir nombres de funciones ya existentes, pero en la realidad es que hay paquetes que tienen funciones que se llama de la misma manera que funciones de otros paquetes (y como no hacerlo, ¡si hay más de 10,000 paquetes en el CRAN!) Ahora, ¿Cómo sabrá R a que función estamos haciendo referencia? Para esto, es muy util saber el namespace de cada paquete. Por ejemplo, una función llamada summarize se encuentra en los paquetes Hmisc y plyr (y tiene distinta funcionalidad cada función), y si están cargados los dos, ¿Cómo hacemos referencia a cada una de estas funciones? Con el namespace: # Hacer referencia a la funcion summarize() del paquete Hmisc Hmisc::summarize() # Hacer referencia a la funcion summarize() del paquete plyr plyr::summarize() 4.3 Paquetería útil para el análisis de datos Gran parte del poder de R proviene de los paquetes que se pueden instalar desde el CRAN. De los paquetes más útiles para analizar datos son los siguientes: Importar datos Tratar datos Desarrollo de paquetes ggplot2: visualizar datos readr: importar .csv y fwf devtools desarrollo de paquetes dplyr: manipular datos readxl: importar .xlsx y .xls roxygen2 desarrollo de documentación tidyr: ordenar datos haven: importar SAP, SPSS y Stata testthat para pruebas unitarias stringr: trabajar con texto httr: comunicarse con APIs web lubridate: trabajar con fechas rvest: scrapping websites 4.4 Estructuras de datos en R En R, al igual que otros lenguajes de programación, hay distintos tipos de estructuras de datos. Las estructuras de datos básicas en R pueden ser organizadas de acuerdo a la dimensionalidad (1d, 2d, nd) y si contienen datos homogéneos o heterogéneos (Es importante destacar que R no tiene datos de 0-dimensional (escalares). Los que parecen ser escalares son de hecho vectores de longitud uno). Dim Homogeneo Heterogeneo 1d vector atómico lista 2d matriz Data Frame nd array Datos homogéneos: 4.4.1 Vectores atómicos Son estructuras de datos homogéneas de una dimensión. Hay cuatro tipos de vectores básicos: lógicos, entero, numéricos y de caracteres. Operaciones: Creación: Son creados con la expresión c() Selección de elementos: Se realiza con [ ], indicando el índice dentro de los corchetes (es posible extraer un valor 3. indexando con números negativos) Agregar nuevo valor: Se asigna un nuevo valor en el índice asignado. Cambiar un valor: Se asigna el nuevo valor sobre un índice ya existente. Buscar un valor: Usando la función match(vector, valor_buscado) se obtiene un vector lógico indicando si la posición es el valor buscado. Operaciones aritméticas: suma, multiplicación Algunas funciones comunes sobre vectores: length: número de elementos en el vector class: clase del vector summary: resumen de información del vector unique: valores únicos del vector table: tabla de frecuencias para cada elemento del vector sum: suma de los elementos del vector mean: promedio de elementos del vector sd: desviación estándar de los elementos del vector cumsum: suma acumulada de elemento anterior del vector 4.4.2 Matrices y arrays. Son estructuras de datos con más de una dimensión. Al igual que el vector, solamente puede contener un tipo de datos en específico. Al tener dos dimensiones, para acceder a un elemento se tiene que indexar sobre los renglones y las columnas. Operaciones: Creación: Son creados con la expresión matrix() Selección de elementos: Se realiza con [ , ], indicando el índice de los renglones y las columnas dentro de los corchetes (es posible extraer un valor indexando con números negativos) Agregar nuevo valor: Se asigna un nuevo valor en los índice asignados. Cambiar un valor: Se asigna el nuevo valor sobre un índices ya existente. Buscar un valor: Usando la función match(matriz, valor_buscado) se obtiene un vector numérico indicando si la posición es el valor buscado. Operaciones aritméticas: suma, multiplicación Algunas funciones comunes sobre matrices: dim: dimensión de una matriz nrow: número de renglones de la matriz rownames: devuelve el nombre de los renglones rbind: une los renglones de dos matrices del mismo tipo con el mismo número de columnas ncol: número de columnas de la matriz colnames: devuelve el nombre de las columnas cbind: une las columnas de dos matrices del mismo tipo con el mismo número de renglones t: para obtener la matriz transpuesta diag: depende del argumento, Si se da un vector como argumento, regresa una matriz diagonal con los elementos del vector como las entradas de la diagonal. Si se da una matriz como argumento, regresa un vector que contiene los elementos de la diagonal de la matriz. Si se da un valor numérico, regresa la matriz identidad multiplicada por dicho valor. 4.4.3 Listas. Una lista puede contener elementos de distinto tipo. Por ejemplo, un elemento puede ser numérico, otro puede ser una cadena de texto y otro un elemento booleano. Inclusive, un elemento de una lista puede ser otra lista. Operaciones: Creación: Son creados con la expresión list() Selección de elementos: Se realiza con [[ ]], indicando el índice dentro de los corchetes (NO es posible extraer un valor indexando con números negativos) Agregar nuevo valor: Se asigna un nuevo valor en el índice asignado y usando [[ ]]. Cambiar un valor: Se asigna el nuevo valor sobre un indice ya existente y usando [[ ]]. Buscar un valor: Usando la función match(vector, valor_buscado) se obtiene un vector lógico indicando si la posición es el valor buscado. Algunas funciones comunes sobre listas: length: número de elementos en la lista class: devuelve la clase lista unique: valores únicos del vector unlist: vuelve un vector la lista. (tener cuidado por que cambia el formato de los datos) 4.4.4 Data.frames Un data.frame es un conjunto de vectores del mismo tamaño agrupados en una tabla. Son estructuras rectangulares donde cada columna tiene elementos de la misma clase, pero entre columnas pueden tener diferentes clases. Operaciones: 1. Creación: Son creados con la expresión data.frame() Selección de elementos: Se puede seleccionar una columna entera con el símbolo $ y el nombre de la columna: dataframe$variable_nombre, se puede seleccionar un elemento en particular al igual que una matriz. Agregar una nueva columna: Se puede asignar una nuevo vector del mismo tamaño como una columna nueva. dataframe$variable_nombra = vector_nuevo Algunas funciones comunes sobre data frames: dim: dimensión de una data.frame nrow: número de renglones de un data.frame rownames: devuelve el nombre de los renglones rbind: une los renglones de dos data.frames del mismo tipo con el mismo número de columas ncol: número de columnas de un data.frame colnames: devuelve el nombre de las columnas cbind: une las columnas de dos data.frames del mismo tipo con el mismo número de renglones summary: se obtiene el resumen de los datos. 4.5 Funciones, condicionales e iteraciones: Al igual que en otros lenguajes de programación, existen 4.5.1 Funciones Una función en R es muy parecido a una función común. Recibe unos parámetros de entrada, los cuales usa para arrojar otros de salida. Los objetos creados dentro de la función son locales, es decir, solamente existen dentro del scope de la función. Si se quiere exportar algún valor, o lista se tiene que mencionar explicitamente. (Por default, las funciones en R devuelven la última linea del código siempre y cuando no sea una asignación). La sintaxis es la siguiente: mi_funcion &lt;- function(valor){ valor_exportado &lt;- 5 valor_no_exportado &lt;- valor valor_exportado } mi_funcion(10) ## [1] 5 4.5.2 Condicionales Otra estructura muy explotada en los lenguajes de programación son los condicionales. Los principales en R son dplyr::if_else y dplyr::case_when. El primero evalua si una expresión es verdadera o falsa y da distinto resultado en caso de ser verdadero y uno en caso de ser falso. El segundo vectoriza multiples condicionales if. Por ejemplo: library(dplyr) x &lt;- c(-5:5, NA) if_else(x &lt; 0, NA_integer_, x) ## [1] NA NA NA NA NA 0 1 2 3 4 5 NA if_else(x &lt; 0, &quot;negativo&quot;, &quot;positivo&quot;, &quot;faltante&quot;) ## [1] &quot;negativo&quot; &quot;negativo&quot; &quot;negativo&quot; &quot;negativo&quot; &quot;negativo&quot; &quot;positivo&quot; ## [7] &quot;positivo&quot; &quot;positivo&quot; &quot;positivo&quot; &quot;positivo&quot; &quot;positivo&quot; &quot;faltante&quot; edad &lt;- 1:10 case_when( edad &gt; 35 ~ &quot;adulto&quot;, edad &gt; 20 ~ &quot;adulto joven&quot;, edad &gt; 10 ~ &quot;adolescente&quot;, TRUE ~ &quot;niño&quot; ) ## [1] &quot;niño&quot; &quot;niño&quot; &quot;niño&quot; &quot;niño&quot; &quot;niño&quot; &quot;niño&quot; &quot;niño&quot; &quot;niño&quot; &quot;niño&quot; &quot;niño&quot; 4.5.3 Iteraciones Las iteraciones en cualquier lenguaje de programación son básicamente replicar un código múltiples veces con el mismo o distintos argumentos. En R los más básicos son los ciclos for, while y repeat: Como se observa en la imagen, el ciclo for se ejecuta n veces con n conocido (o bien, sobre un vector ya conocido). Por otra parte, un ciclo while se ejecuta mientras una condición se cumpla, por lo que teóricamente puede seguir iterando mientras no se cumpla dicha condición. Finalmente, en el ciclo repeat se repite el código hasta que explicitamente se salga del código con un comando llamado break. Los dos comandos faltantes son next y break. El primero sirve para terminal la iteración actual y continuar con la siguiente, mientras que el segundo sirve para salir por completo del ciclo. # ejemplos de for: for (numero in 1:3){ print(paste(&quot;El número es&quot;, numero)) } ## [1] &quot;El número es 1&quot; ## [1] &quot;El número es 2&quot; ## [1] &quot;El número es 3&quot; for (anio in c(2015,2016,2017,2018)){ print(paste(&quot;El año es&quot;, anio)) } ## [1] &quot;El año es 2015&quot; ## [1] &quot;El año es 2016&quot; ## [1] &quot;El año es 2017&quot; ## [1] &quot;El año es 2018&quot; # ejemplo de while i &lt;- 1 while (i &lt; 6) { print(i) i = i+1 } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 # ejemplo de repeat (con break) x &lt;- 1 repeat { print(x) x = x+1 if (x == 6){ break } } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 # ejemplo de repeat (con break y next) x &lt;- 1 repeat { if (x == 3){ x = x+1 next } print(x) x = x+1 if (x == 6){ break } } ## [1] 1 ## [1] 2 ## [1] 4 ## [1] 5 4.5.3.1 Familia apply (base package) Las funciones de la familia apply: apply(), lapply(), sapply(), mapply() sirven para iterar sobre datos en matrices, arrays, listas y data.frames con muy pocas lineas de código. La manera de usar cada una de estas funciones es la siguiente: apply(X, MARGIN, FUN, ...): funciona sobre arrays, con MARGIN la dimension sobre la cual se aplicara una funcion FUN m &lt;- matrix(c(1:10, 11:20), nrow = 10, ncol = 2) apply(m, 1, mean) ## [1] 6 7 8 9 10 11 12 13 14 15 apply(m, 2, mean) ## [1] 5.5 15.5 lapply(X, FUN, ...): es muy similar a apply(), pero toma una lista como entrada y regresa una lista como salida l &lt;- list(a = 1:10, b = 11:20) lapply(l, mean) ## $a ## [1] 5.5 ## ## $b ## [1] 15.5 lapply(l, sum) ## $a ## [1] 55 ## ## $b ## [1] 155 sapply(X, FUN, ...): es basicamente igual a lapply(), pero la salida no es una lista, si no un vector, matriz o array (el que sea más apropiado). En mi opinión, esta función debe evitarse ya que hay incertidumbre en el formato de salida al aplicarla. l &lt;- list(a = 1:10, b = 11:20) sapply(l, mean) ## a b ## 5.5 15.5 mapply(X, FUN, ...): es una versión multivariada de sapply(). Se aplica la funcion FUN al primer elemento de cada argumento, del segundo elemento, del tercer elemento, etc. l1 &lt;- list(a = c(1:10), b = c(11:20)) l2 &lt;- list(c = c(21:30), d = c(31:40)) mapply(sum, l1$a, l1$b, l2$c, l2$d) ## [1] 64 68 72 76 80 84 88 92 96 100 Aunque en cuando a performance no hay ventaja en usar la familia apply(), se tienen otras ventajas como: Se crea un código más legible (no se tienen que preocuparse por manejar el output, ni por problemas de corchetes) Se permite crear código más rápido (una vez dominada la familia apply) Como se mencionó antes, R esta basádo en vectores, matrices, arrays, lists y data.frames, por lo que esta familia de funciones está diseñada para trabajar con estas estructuras de datos. Las principales desventajas sobre la familia apply() son las siguientes: No son estables en el tipo de salida (no sabes si se generará un vector de carácteres, numérico, de booleanos, etc). No está estandarizado el orden de los argumentos. Estas debilidades de la familia apply() motivaron la creación de otra familia más reciente: la familia map() del paquete purrr, que se abordará a continuación. 4.5.3.2 familia map() (purrr package) map(), map_if(), map_at(): itera sobre un vector o lista y retorna una lista. library(purrr) # ejemplo de map original map(c(9, 16, 25), sqrt) ## [[1]] ## [1] 3 ## ## [[2]] ## [1] 4 ## ## [[3]] ## [1] 5 # ejemplo de map_if es_par &lt;- function(x){ !as.logical(x %% 2) } numbers &lt;- list(11, 12, 13, 14) map_if(numbers, es_par, sqrt) ## [[1]] ## [1] 11 ## ## [[2]] ## [1] 3.464102 ## ## [[3]] ## [1] 13 ## ## [[4]] ## [1] 3.741657 # ejemplo de map_at map_at(numbers, c(1,3), sqrt) ## [[1]] ## [1] 3.316625 ## ## [[2]] ## [1] 12 ## ## [[3]] ## [1] 3.605551 ## ## [[4]] ## [1] 14 map_chr(), map_dbl(), map_int(), map_lgl(): itera sobre un vector o lista y retorna un vector de caracteres, numérico, de enteros o booleano. # el orden de transformación es lgl -&gt; int -&gt; dbl -&gt; chr # por ejemplo un dbl no puede transformarse en un int, pero si en un chr map_chr(c(9, 16, 25), sqrt) ## [1] &quot;3.000000&quot; &quot;4.000000&quot; &quot;5.000000&quot; map_dbl(c(9, 16, 25), sqrt) ## [1] 3 4 5 # por ejemplo un lgl puede transformarse en un int, en un dbl y en un chr map_chr(c(TRUE, FALSE, TRUE), identity) ## [1] &quot;TRUE&quot; &quot;FALSE&quot; &quot;TRUE&quot; map_dbl(c(TRUE, FALSE, TRUE), identity) ## [1] 1 0 1 map_int(c(TRUE, FALSE, TRUE), identity) ## [1] 1 0 1 map_lgl(c(TRUE, FALSE, TRUE), identity) ## [1] TRUE FALSE TRUE map2(), pmap(): Son un variante de la funcion map() que permite iterar sobre multiples argumentos en paralelo. numbers2 &lt;- list(1, 2, 3, 4) map2(numbers, numbers2, `+`) ## [[1]] ## [1] 12 ## ## [[2]] ## [1] 14 ## ## [[3]] ## [1] 16 ## ## [[4]] ## [1] 18 pmap(list(numbers, numbers2, numbers2), sum) ## [[1]] ## [1] 13 ## ## [[2]] ## [1] 16 ## ## [[3]] ## [1] 19 ## ## [[4]] ## [1] 22 map_dfr() y map_dfc(): regresa data.frames creados por concatenación de renglones o de columnas (respectivamente) 4.6 Ejercicios de practica 4.6.1 Ejercicio 3 Tipo de datos: String, double, integer, boolean Vector Atomico: vector con elementos del mismo tipo (string, double, entero) Matrix: vector de dos dimensiones con elementos del mismo tipo (string, double, entero) Lista: unidimensional elementos de distinto tipo (string, double, entero) Dataframe: multidimensional que nos permite almacenar una tabla o base de datos en R. Se compone de columnas y renglones Tipos de dato: soy_string &lt;- &quot;Hola soy una cadena de texto&quot; soy_double &lt;- 5.3 soy_integer &lt;- 5 soy_boolean &lt;- TRUE Vector atómico: soy_vector_atomico &lt;- c(1,2,3) var(soy_vector_atomico) ## [1] 1 mean(soy_vector_atomico) ## [1] 2 length(soy_vector_atomico) ## [1] 3 Matriz: soy_matrix &lt;- matrix(c(1,2,3,4), ncol = 2) mean(matrix) ## Warning in mean.default(matrix): argument is not numeric or logical: returning ## NA ## [1] NA dim(matrix) ## NULL Lista: soy_lista &lt;- list(1, &quot;texto&quot;, 1.5, 1) length(soy_lista) ## [1] 4 unique(soy_lista) ## [[1]] ## [1] 1 ## ## [[2]] ## [1] &quot;texto&quot; ## ## [[3]] ## [1] 1.5 Dataframe: soy_data_frame &lt;- data.frame(col1 = c(&quot;text1&quot;, &quot;text2&quot;), col2 = c(1,2)) dim(soy_data_frame) ## [1] 2 2 colnames(soy_data_frame) ## [1] &quot;col1&quot; &quot;col2&quot; summary(soy_data_frame) ## col1 col2 ## Length:2 Min. :1.00 ## Class :character 1st Qu.:1.25 ## Mode :character Median :1.50 ## Mean :1.50 ## 3rd Qu.:1.75 ## Max. :2.00 Operaciones comunes dataframe: head(mtcars, 5) # obtiene primeros 5 registros ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 tail(mtcars, 5) # obtiene ultimos 5 registros ## mpg cyl disp hp drat wt qsec vs am gear carb ## Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.9 1 1 5 2 ## Ford Pantera L 15.8 8 351.0 264 4.22 3.170 14.5 0 1 5 4 ## Ferrari Dino 19.7 6 145.0 175 3.62 2.770 15.5 0 1 5 6 ## Maserati Bora 15.0 8 301.0 335 3.54 3.570 14.6 0 1 5 8 ## Volvo 142E 21.4 4 121.0 109 4.11 2.780 18.6 1 1 4 2 al operador %&gt;% (en paquete magrittr) se le conoce como pipe, sirve para pasar datos (en un substituto de anidación): install.packages(&quot;magrittr&quot;, repo=&quot;http://cran.rstudio.com/&quot;) ## ## The downloaded binary packages are in ## /var/folders/t4/6cs23xyn51b429l5x8q39fl80000gp/T//RtmpksfokQ/downloaded_packages library(magrittr) ## ## Attaching package: &#39;magrittr&#39; ## The following object is masked from &#39;package:purrr&#39;: ## ## set_names tail(head(mtcars, 10), 5) ## mpg cyl disp hp drat wt qsec vs am gear carb ## Valiant 18.1 6 225.0 105 2.76 3.46 20.22 1 0 3 1 ## Duster 360 14.3 8 360.0 245 3.21 3.57 15.84 0 0 3 4 ## Merc 240D 24.4 4 146.7 62 3.69 3.19 20.00 1 0 4 2 ## Merc 230 22.8 4 140.8 95 3.92 3.15 22.90 1 0 4 2 ## Merc 280 19.2 6 167.6 123 3.92 3.44 18.30 1 0 4 4 mtcars %&gt;% head(10) %&gt;% tail(5) ## mpg cyl disp hp drat wt qsec vs am gear carb ## Valiant 18.1 6 225.0 105 2.76 3.46 20.22 1 0 3 1 ## Duster 360 14.3 8 360.0 245 3.21 3.57 15.84 0 0 3 4 ## Merc 240D 24.4 4 146.7 62 3.69 3.19 20.00 1 0 4 2 ## Merc 230 22.8 4 140.8 95 3.92 3.15 22.90 1 0 4 2 ## Merc 280 19.2 6 167.6 123 3.92 3.44 18.30 1 0 4 4 mtcars %&gt;% head(5) ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 mtcars %&gt;% tail(5) ## mpg cyl disp hp drat wt qsec vs am gear carb ## Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.9 1 1 5 2 ## Ford Pantera L 15.8 8 351.0 264 4.22 3.170 14.5 0 1 5 4 ## Ferrari Dino 19.7 6 145.0 175 3.62 2.770 15.5 0 1 5 6 ## Maserati Bora 15.0 8 301.0 335 3.54 3.570 14.6 0 1 5 8 ## Volvo 142E 21.4 4 121.0 109 4.11 2.780 18.6 1 1 4 2 "],["importar-datos.html", "Chapter 5 Importar datos 5.1 Archivos .csv 5.2 Archivos .xlsx y .xls 5.3 Otros formatos de archivos .sav, .data, .sas 5.4 Ejercicios de práctica", " Chapter 5 Importar datos Una parte importante al usar R es importar datos desde un archivo externo de datos. Las extensiones más comunes de estos archivos son separados por coma: *.csv, archivos de excel *.xlsx, *.xls, archivos de SPSS *.sav, archivos de STATA *.dta o archivos de SAS *.sas 5.1 Archivos .csv Importar archivos desde csv con R se puede realizar de tres maneras: Con la función: utils::read.csv(), con la función readr::read_csv() y con la funcion data.table::fread(). La función más rápida es fread()del paquete data.table, seguida de la función read_csv y después la función read.csv. Las ventajas de la función read_csv es que el parsing de las columnas es más facil; es decir, detecta mejor si es una columna numérica, si tiene formato de fecha, de caracter, etc. Por otra parte la única ventaja de la función read.csv es que viene incluida en la paquetería core de R. En mi opinión, si se tiene una cantidad moderada de datos y se quiere hacer análisis de datos, la función óptima es read_csv. 5.2 Archivos .xlsx y .xls Para leer archivos xlsx y xls también hay distintas opciones, entre ellas los paquetes XLConnect, xlsx, gdata y readxl. Cada uno de estos paquetes tiene distintas funcionalidades y provienen de diferentes paradigmas, pero la opción que les recomendaría es la función read_excel() del paquete readxl. La instalación del paquete es muy rápida y tiene compatibilidad con otros paquetes de análisis de datos de R. Esta función trabaja de la siguiente manera: readxl::read_excel() 5.3 Otros formatos de archivos .sav, .data, .sas Al igual que las dos subsecciones pasadas, hay distintos paquetes para leer archivos de SPSS, STATA y SAS, pero una de las mejores opciones es el paquete haven. Este paquete permite importar y exportar estos archivos facilmente: haven::read_spss() haven::read_stata() haven::read_sas() Una de los principales motivos de la selección de estos paquetes es que son compatibles con una colección de paquetes que se les llama el tidyverse, el cual fue diseñado por Hadley Wickham, el CEO de RStudio. Esta colección está diseñada bajo la misma gramática, filosofía y estructuras de datos. En estas notas hay una sección especial dedicada a esta colección de paquetes. 5.4 Ejercicios de práctica 5.4.1 Ejercicio 4 library(readr) readr::write_csv(mtcars, &quot;data/mtcars/mtcars.csv&quot;) file &lt;- readr::read_csv(&quot;data/mtcars/mtcars.csv&quot;) ## ## ── Column specification ──────────────────────────────────────────────────────── ## cols( ## mpg = col_double(), ## cyl = col_double(), ## disp = col_double(), ## hp = col_double(), ## drat = col_double(), ## wt = col_double(), ## qsec = col_double(), ## vs = col_double(), ## am = col_double(), ## gear = col_double(), ## carb = col_double() ## ) readr::write_delim(mtcars, &quot;data/mtcars/mtcars.txt&quot;, delim = &quot;\\t&quot;) file &lt;- readr::read_delim(&quot;data/mtcars/mtcars.txt&quot;, delim = &quot;\\t&quot;) ## ## ── Column specification ──────────────────────────────────────────────────────── ## cols( ## mpg = col_double(), ## cyl = col_double(), ## disp = col_double(), ## hp = col_double(), ## drat = col_double(), ## wt = col_double(), ## qsec = col_double(), ## vs = col_double(), ## am = col_double(), ## gear = col_double(), ## carb = col_double() ## ) 5.4.2 Ejercicio 5 library(readxl) library(writexl) writexl::write_xlsx(mtcars, &quot;data/mtcars/mtcars.xlsx&quot;) file &lt;- readxl::read_excel(&quot;data/mtcars/mtcars.xlsx&quot;) 5.4.3 Ejercicio 6 library(haven) haven::write_sas(mtcars, &quot;data/mtcars/mtcars.sas7bdat&quot;) file &lt;- haven::read_sas(&quot;data/mtcars/mtcars.sas7bdat&quot;) "],["dataset-transformation.html", "Chapter 6 Dataset transformation 6.1 Formato largo y ancho de bases", " Chapter 6 Dataset transformation 6.1 Formato largo y ancho de bases En procesamiento de bases comunmente se utilizan dos tipos de layout (largo/long, ancho/wide). En el formato wide, se tiene un renglon por cada data point y multiples columnas que contienen los atributos. En el formato long, cada punto se repite n veces de acuerdo al nùmero de atributos. R viene con algunos databases integrados, mtcars es uno de ellos. tidyr::gather() pasa de formato ancho a largo tidyr::spread() pasa de formato largo a ancho Ejemplo de formato ancho: library(tidyr) wide_db &lt;- mtcars %&gt;% dplyr::mutate(car_type = row.names(.)) %&gt;% dplyr::filter(car_type == &quot;Camaro Z28&quot;) wide_db ## mpg cyl disp hp drat wt qsec vs am gear carb car_type ## 1 13.3 8 350 245 3.73 3.84 15.41 0 0 3 4 Camaro Z28 Ejemplo de formato largo: long_db &lt;- wide_db %&gt;% tidyr::gather(attribute, value, mpg:carb) long_db ## car_type attribute value ## 1 Camaro Z28 mpg 13.30 ## 2 Camaro Z28 cyl 8.00 ## 3 Camaro Z28 disp 350.00 ## 4 Camaro Z28 hp 245.00 ## 5 Camaro Z28 drat 3.73 ## 6 Camaro Z28 wt 3.84 ## 7 Camaro Z28 qsec 15.41 ## 8 Camaro Z28 vs 0.00 ## 9 Camaro Z28 am 0.00 ## 10 Camaro Z28 gear 3.00 ## 11 Camaro Z28 carb 4.00 El formato que comunmente estamos acostumbrados es el ancho, pero para R y procesamiento de datos es más común y mejor práctica trabajar sobre formatos largos. "],["visualización-de-datos.html", "Chapter 7 Visualización de datos 7.1 tidyverse 7.2 ggplot 7.3 Ejercicios de práctica", " Chapter 7 Visualización de datos 7.1 tidyverse Tidyverse es una colección de paquetes/librerias que sirven para el análisis de datos, este consiste en un grupo de paquetes para facilitar el trabajo con datos. 7.2 ggplot ggplot es el paquete de visualización de datos que consiste en distintos elementos. Hay que diferenciar entre los distintos conceptos: ggplot2 es una libreria que trabaja por ‘capas’ y trabaja sobre formatos largos de base de datos ggplot(): es la base de la gráfica. Inicializa una grafica vacia. aes(): se les llama los aesthetics. Es lo que define en que valor de x, y, color, relleno, tamaño tendrá la gráfica Todas las funciones de ggplot que inician con geom_ definen distintos tipos de gráficas. geom_point(): Te define una grafica de puntos (o scatterplot). geom_bar(): Te define una grafica de barras (o barplot) geom_histogram(): Te define un histograma geom_line(): Te define una gráfica de linea geom_boxplot(): Te define gráfica de boxplot Asi como muchos otros tipos de gráfica. A cada gráfica le podemos añadir o modificar cuestiones del formato. theme(): dentro de esta funcion podemos agregar o modificar particularidades de la grafica Además, se le puede modificar el texto de la gráfica labs(): te permite modificar el texto del eje x, eje y, titulo, subtitulo, caption, etc 7.2.1 Scatterplot Sin formato library(tidyverse) ## ── Attaching packages ─────────────────────────────────────── tidyverse 1.3.0 ── ## ✓ ggplot2 3.3.2 ✓ purrr 0.3.4 ## ✓ tibble 3.0.4 ✓ dplyr 1.0.2 ## ✓ tidyr 1.1.2 ✓ stringr 1.4.0 ## ✓ readr 1.4.0 ✓ forcats 0.5.0 ## ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ── ## x dplyr::filter() masks stats::filter() ## x dplyr::lag() masks stats::lag() mtcars %&gt;% dplyr::mutate(car_type = row.names(.)) %&gt;% ggplot() + # crea un empty plot geom_point(aes(x = car_type, y = carb, color = carb)) + # vamos agregando capas theme(axis.text.x = element_text(angle = 90, hjust = 1)) + # agregamos formato labs(title = &quot;Automoviles por nùmero de cilindros&quot;, subtitle = &quot;Se pueden añadir distintos elementos a la grafica&quot;, caption = &quot;Tambien se pueden añadir pies de nota&quot;, x = &quot;Tipo de automovil&quot;, y = &quot;Númerop de cilindros&quot;) + # tambièn se pueden agregar elementos extra theme_minimal() # incluso se puede sobreescribir los elementos definidos previamente Con formato mtcars %&gt;% dplyr::mutate(car_type = row.names(.)) %&gt;% ggplot() + geom_point(aes(x = car_type, y = carb, color = factor(carb), size = carb)) + theme_minimal()+ theme(axis.text.x = element_text(angle = 90, hjust = 1), legend.position = &quot;bottom&quot;) + labs(title = &quot;Automoviles por nùmero de cilindros&quot;, subtitle = &quot;Se pueden añadir distintos elementos a la grafica&quot;, caption = &quot;Tambien se pueden añadir pies de nota&quot;, x = &quot;Tipo de automovil&quot;, y = &quot;Número de cilindros&quot;, color = &quot;Número de cilindros&quot;) + guides(size = FALSE) 7.2.2 Barplot mtcars %&gt;% dplyr::mutate(car_type = row.names(.)) %&gt;% ggplot() + geom_bar(aes(x = factor(carb), fill = factor(carb)), stat = &quot;count&quot;) + theme_minimal() + scale_fill_manual(values = c(&quot;dodgerblue4&quot;, &quot;firebrick4&quot;, &quot;goldenrod3&quot;, &quot;darkslategray4&quot;, &quot;deeppink4&quot;, &quot;chartreuse4&quot;))+ theme(axis.text.x = element_text(angle = 90, hjust = 1), legend.position = &quot;bottom&quot;) + labs(title = &quot;Automoviles por nùmero de cilindros&quot;, subtitle = &quot;Se pueden añadir distintos elementos a la grafica&quot;, caption = &quot;Tambien se pueden añadir pies de nota&quot;, x = &quot;Tipo de automovil&quot;, y = &quot;Número de cilindros&quot;, color = &quot;Número de cilindros&quot;) + guides(size = FALSE)+ theme() 7.3 Ejercicios de práctica 7.3.1 Ejercicio 7 tidyr::gather() pasa de formato ancho a largo tidyr::spread() pasa de formato largo a ancho library(dplyr) library(tidyr) wide_db &lt;- mtcars %&gt;% dplyr::mutate(car_type = row.names(.)) %&gt;% dplyr::filter(car_type == &quot;Camaro Z28&quot;) wide_db %&gt;% head ## mpg cyl disp hp drat wt qsec vs am gear carb car_type ## 1 13.3 8 350 245 3.73 3.84 15.41 0 0 3 4 Camaro Z28 long_db &lt;- wide_db %&gt;% tidyr::gather(attribute, value, mpg:carb) long_db %&gt;% head ## car_type attribute value ## 1 Camaro Z28 mpg 13.30 ## 2 Camaro Z28 cyl 8.00 ## 3 Camaro Z28 disp 350.00 ## 4 Camaro Z28 hp 245.00 ## 5 Camaro Z28 drat 3.73 ## 6 Camaro Z28 wt 3.84 wide_db &lt;- long_db %&gt;% tidyr::spread(attribute, value) 7.3.2 Ejercicio 8 Analiza como se transiciona del siguiente chunk de código: library(ggplot2) mtcars %&gt;% dplyr::mutate(car_type = row.names(.)) %&gt;% ggplot() + # crea un empty plot geom_point(aes(x = car_type, y = carb, color = carb)) + # vamos agregando capas theme(axis.text.x = element_text(angle = 90, hjust = 1)) + # agregamos formato labs(title = &quot;Automoviles por nùmero de cilindros&quot;, subtitle = &quot;Se pueden añadir distintos elementos a la grafica&quot;, caption = &quot;Tambien se pueden añadir pies de nota&quot;, x = &quot;Tipo de automovil&quot;, y = &quot;Númerop de cilindros&quot;) + # tambièn se pueden agregar elementos extra theme_minimal() # incluso se puede sobreescribir los elementos definidos previamente 7.3.3 Ejercicio 9 mtcars %&gt;% dplyr::mutate(car_type = row.names(.)) %&gt;% ggplot() + geom_point(aes(x = car_type, y = carb, color = factor(carb), size = carb)) + theme_minimal()+ theme(axis.text.x = element_text(angle = 90, hjust = 1), legend.position = &quot;bottom&quot;) + labs(title = &quot;Automoviles por nùmero de cilindros&quot;, subtitle = &quot;Se pueden añadir distintos elementos a la grafica&quot;, caption = &quot;Tambien se pueden añadir pies de nota&quot;, x = &quot;Tipo de automovil&quot;, y = &quot;Número de cilindros&quot;, color = &quot;Número de cilindros&quot;) + guides(size = FALSE) "],["introducción-a-estadística.html", "Chapter 8 Introducción a estadística 8.1 Ejercicios de práctica", " Chapter 8 Introducción a estadística library(crayon) library(tidyverse) ## ── Attaching packages ─────────────────────────────────────── tidyverse 1.3.0 ── ## ✓ ggplot2 3.3.2 ✓ purrr 0.3.4 ## ✓ tibble 3.0.4 ✓ dplyr 1.0.2 ## ✓ tidyr 1.1.2 ✓ stringr 1.4.0 ## ✓ readr 1.4.0 ✓ forcats 0.5.0 ## ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ── ## x ggplot2::%+%() masks crayon::%+%() ## x dplyr::filter() masks stats::filter() ## x dplyr::lag() masks stats::lag() library(Hmisc) ## Loading required package: lattice ## Loading required package: survival ## Loading required package: Formula ## ## Attaching package: &#39;Hmisc&#39; ## The following objects are masked from &#39;package:dplyr&#39;: ## ## src, summarize ## The following objects are masked from &#39;package:base&#39;: ## ## format.pval, units library(plyr) ## ------------------------------------------------------------------------------ ## You have loaded plyr after dplyr - this is likely to cause problems. ## If you need functions from both plyr and dplyr, please load plyr first, then dplyr: ## library(plyr); library(dplyr) ## ------------------------------------------------------------------------------ ## ## Attaching package: &#39;plyr&#39; ## The following objects are masked from &#39;package:Hmisc&#39;: ## ## is.discrete, summarize ## The following objects are masked from &#39;package:dplyr&#39;: ## ## arrange, count, desc, failwith, id, mutate, rename, summarise, ## summarize ## The following object is masked from &#39;package:purrr&#39;: ## ## compact px = 14/488 py = 5/488 # Z (simetrica) qnorm(.025, lower.tail = T) ## [1] -1.959964 qnorm(.025, lower.tail = F) ## [1] 1.959964 ## Valor-p pnorm(-1.959964, lower.tail = T) ## [1] 0.025 # T (simetrica) qt(.025, df = 11, lower.tail = T) ## [1] -2.200985 qt(.025, df = 11, lower.tail = F) ## [1] 2.200985 # J (no simetrica) qchisq(.025, df = 11, lower.tail = T) ## [1] 3.815748 qchisq(.025, df = 11, lower.tail = F) ## [1] 21.92005 # J (no simetrica) qf(.025, df1 = 11, df2 = 38, lower.tail = T) ## [1] 0.3256995 qf(.025, df1 = 11, df2 = 38, lower.tail = F) ## [1] 2.35346 Para esta sección de estadística básica veremos funciones asociadas a distribuciones. Estas son de 4 tipos para varios tipos de distribución: # dnorm, dt, dchisq, df funcion de distribución de la normal, t-student, chisquared, f # Nos dice la &#39;altura&#39; en los puntos dados. Para distribuciones continuas no es muy util, pero para discretas si dnorm(x = c(-100, -1, 0, 1, 100),mean = 0, sd = 1) ## [1] 0.0000000 0.2419707 0.3989423 0.2419707 0.0000000 dbinom(x = c(0,1,2), size = 2, prob = .5) ## [1] 0.25 0.50 0.25 # qnorm, qt, qchisq, qf la funcion quantile de las distribuciones. Recibe como argumento la probabilidad y devuelve el valor del quantil qnorm(p = c(0,.5,1), mean = 0, sd = 1) # en que valor te acumula 0%, 50% y 100% ## [1] -Inf 0 Inf # pnorm, pt, pchisq, pf la funcion inversa a la quantile. cuanta probabilidad te acumula en los valores dados pnorm(q = c(-Inf, 0, Inf), mean = 0, sd = 1) ## [1] 0.0 0.5 1.0 # rnorm, rt, rchisq, rf te devuelve random samples de la distribución en cuestión rnorm(n = 10, mean = 0, sd = 1) ## [1] 0.12877065 0.04790421 1.38931905 -0.60214263 0.16630006 1.89267584 ## [7] 0.80922873 1.62335347 2.43513729 0.47953856 8.1 Ejercicios de práctica 8.1.1 Ejercicio 10 library(tidyverse) data.frame(x = c(seq(-10, 10, by = .01))) %&gt;% mutate( normal = dnorm(x = x, mean = 0, sd = 1), t_student = dt(x = x, df = 10), chi_sq = dchisq(x = x, df = 10), unif = dunif(x = x, min = min(x), max = max(x)) ) %&gt;% gather(distribucion, valor, normal:unif) %&gt;% ggplot(aes(x = x, y = valor, color = distribucion))+ geom_line()+ facet_wrap(~distribucion, ncol = 2)+ theme_minimal() 8.1.2 Distribution function data.frame(q = c(seq(-10, 10, by = .01))) %&gt;% mutate( normal = pnorm(q = q, mean = 0, sd = 1), t_student = pt(q = q, df = 10), chi_sq = pchisq(q = q, df = 1), unif = punif(q = q, min = min(q), max = max(q)) ) %&gt;% gather(distribucion, valor, normal:unif) %&gt;% ggplot(aes(x = q, y = valor, color = distribucion))+ geom_line()+ facet_wrap(~distribucion, ncol = 2)+ theme_minimal() 8.1.3 Quantile function data.frame(q = c(seq(0.01, .99, by = .01))) %&gt;% mutate( normal = qnorm(p = q, mean = 0, sd = 1), t_student = qt(p = q, df = 10), chi_sq = qchisq(p = q, df = 1), unif = qunif(p = q, min = min(q), max = max(q)) ) %&gt;% gather(distribucion, valor, normal:unif) %&gt;% ggplot(aes(x = q, y = valor, color = distribucion))+ geom_line()+ facet_wrap(~distribucion, ncol = 2)+ theme_minimal() 8.1.4 Random function data.frame( normal = rnorm(n = 10000, mean = 0, sd = 1), t_student = rt(n = 10000, df = 10), chi_sq = rchisq(n = 10000, df = 1), unif = runif(n = 10000, min = -3, max = 3) ) %&gt;% gather(distribucion, valor, normal:unif) %&gt;% ggplot(aes(x = valor, fill = distribucion))+ geom_density()+ facet_wrap(~distribucion, ncol = 2)+ theme_minimal() "],["estadistica-inferencial.html", "Chapter 9 Estadistica inferencial 9.1 Estimación por intervalos 9.2 Estadístico Z - Media (varianza conocida) 9.3 Estadístico T - Media (varianza desconocida) 9.4 Estadístico J - Varianza 9.5 Estadístico F - Cociente de varianzas 9.6 Tamaño de muestra 9.7 Pruebas de hipótesis 9.8 Ejemplo de estadístico Z 9.9 Ejemplo de estadistico T 9.10 Ejemplo de estadistico J 9.11 Ejemplo de estadistico F", " Chapter 9 Estadistica inferencial 9.1 Estimación por intervalos El capítulo anterior abordó estimación puntual, que proporciona o estima un solo valor para darnos una idea del parámetro \\(\\theta\\). En ocasiones estimar un solo valor no es suficiente por que se requiere tener un rango de valores donde creemos se encuentra el parámetro. Nivel de confianza: Grado de seguridad que se tiene sobre la veracidad de una afirmación acerca del parámetro (o parámetros) de interés. El nivel de confianza se denota como \\((1-\\alpha)\\) con \\(\\alpha\\) constante entre 0 y 1. Intervalo de confianza (IC): Rango de valores en el que se encuentra el verdadero valor del parámetro \\(\\theta\\). Este rango de valores es dependiente la nivel de confianza \\((1-\\alpha)\\). Sean \\(a\\) y \\(b\\) dos valores tal que: \\[P(a \\leq \\theta \\leq b) = 1 - \\alpha\\] Entonces \\((a, b)\\) es un intervalo tal que la probabilidad que el verdadero parámetro \\(\\theta\\) se encuentre dentro de los valores es \\((1-\\alpha)\\) 9.2 Estadístico Z - Media (varianza conocida) Recordando clases pasadas, se había encontrado la distrubión de los estimadores de la media (\\(\\overline{X}\\)). De acuerdo si se tenía una varianza conocida o desconocida, el estimador \\(\\overline{X}\\) se podía distribuir normalmente o como una distribución t-student respectivamente. 9.2.1 IC para media Si se tienen \\(n\\) datos, donda cada \\(X_i\\) se modela con media \\(\\mu\\) y varianza \\(\\sigma^2\\) conocida, entonces tenemos que: \\[Z = \\left(\\frac{\\overline{X}-\\mu} {\\sigma/\\sqrt{n}} \\right) = \\left(\\frac{\\overline{X}-\\mu} {\\sqrt{\\frac{\\sigma^2}{n}}} \\right) \\sim N\\left(0,1\\right)\\] Sean \\(-z_{\\alpha/2}\\) y \\(z_{\\alpha_2}\\) puntos críticos, tal que: \\[ P \\left( -z_{\\alpha/2} \\leq Z \\leq z_{\\alpha/2}\\right) = 1-\\alpha\\\\ P\\left(-z_{\\alpha/2} \\leq \\frac{\\overline{X}-\\mu} {\\sqrt{\\frac{\\sigma^2}{n}}} \\leq z_{\\alpha/2}\\right) = 1-\\alpha\\\\ P\\left(\\overline{X} - z_{\\alpha/2} {\\sqrt{\\frac{\\sigma^2}{n}}} \\leq \\mu \\leq \\overline{X} + z_{\\alpha/2} {\\sqrt{\\frac{\\sigma^2}{n}}}\\right) = 1-\\alpha \\] Entonces el intervalo de confianza para \\(\\mu\\) puede ser expresado como: \\[\\begin{equation} \\boxed{\\left(\\overline{X} - z_{\\alpha/2} \\frac{\\sigma}{\\sqrt{n}}, \\overline{X} + z_{\\alpha/2} \\frac{\\sigma}{\\sqrt{n}}\\right)} \\tag{9.1} \\end{equation}\\] 9.2.2 IC para proporción La proporción se puede ver como un caso particular de una media, solo que para el caso en el que cada \\(X_i\\) se distribuye Bernoulli. \\[Z = \\left(\\frac{\\overline{X}-\\mu}{\\sqrt{\\frac{\\sigma^2}{n}}}\\right) = \\left(\\frac{\\hat{p}-p}{\\sqrt{\\frac{p(1-p)}{n}}}\\right) \\sim N\\left(0,1\\right)\\] Sean \\(-z_{\\alpha/2}\\) y \\(z_{\\alpha_2}\\) como puntos críticos, tal que: \\[ P\\left(-z_{\\alpha/2} \\leq Z \\leq z_{\\alpha/2}\\right) = 1-\\alpha \\\\ \\\\ P\\left(-z_{\\alpha/2} \\leq \\frac{\\hat{p}-p}{\\sqrt{\\frac{p(1-p)}{n}}} \\leq z_{\\alpha/2}\\right) = 1-\\alpha\\\\ \\\\ P\\left(\\hat{p} - z_{\\alpha/2} {\\sqrt{\\frac{p(1-p)}{n}}} \\leq p \\leq \\hat{p} + z_{\\alpha/2} {\\sqrt{\\frac{p(1-p)}{n}}}\\right) = 1-\\alpha \\] Entonces el intervalo de confianza puede ser expresado como: \\[\\begin{equation} \\boxed{\\left(\\hat{p} - z_{\\alpha/2} \\sqrt{\\frac{p(1-p)}{n}}, \\hat{p} + z_{\\alpha/2} \\sqrt{\\frac{p(1-p)}{n}} \\right)} \\tag{9.2} \\end{equation}\\] 9.2.3 IC diferencia de medias (muestras independientes) En el caso de tener dos poblaciones es posible medir la diferencia de medias entre las poblaciones. Se le llama muestra independientes cuando no hay relación entre una u otra población. En cambio cuando son dependientes comúnmente son muestras pareadas (siguiente sección). En el caso de independencia y asumiendo normalidad, se tienen dos poblaciones \\(X \\sim N(\\mu_x, \\sigma_X^2)\\) y \\(Y \\sim N(\\mu_y, \\sigma_Y^2)\\). En esta sección se asume que se conoce la varianza de ambas poblaciones. Con estos supuestos se sabe que \\(\\overline{Y}-\\overline{X} \\sim N(\\mu_{Y}-\\mu_{X},\\frac{\\sigma_X^2}{n}+\\frac{\\sigma_Y^2}{m})\\). De esta manera podemos escribir a Z como: \\[Z = \\frac{\\left(\\overline{Y}-\\overline{X}\\right) -\\left(\\mu_{Y}-\\mu_{X}\\right)}{\\sqrt{\\frac{\\sigma_X^2}{n}+\\frac{\\sigma_Y^2}{m}}} \\sim N\\left(0,1\\right)\\] Sean \\(-z_{\\alpha/2}\\) y \\(z_{\\alpha_2}\\) puntos críticos, tal que: \\[ P\\left(-z_{\\alpha/2} \\leq Z \\leq z_{\\alpha/2}\\right) = 1-\\alpha \\\\ \\\\ P\\left(-z_{\\alpha/2} \\leq \\frac{\\left(\\overline{Y}-\\overline{X}\\right) -\\left(\\mu_{Y}-\\mu_{X}\\right)}{\\sqrt{\\frac{\\sigma_X^2}{n}+\\frac{\\sigma_Y^2}{m}}} \\leq z_{\\alpha/2}\\right) = 1-\\alpha\\\\ \\\\ P\\left(\\left(\\overline{Y}-\\overline{X}\\right) - z_{\\alpha/2} \\sqrt{\\frac{\\sigma_X^2}{n}+\\frac{\\sigma_Y^2}{m}} \\leq \\mu_Y-\\mu_X \\leq \\left(\\overline{Y}-\\overline{X}\\right) + z_{\\alpha/2} \\sqrt{\\frac{\\sigma_X^2}{n}+\\frac{\\sigma_Y^2}{m}}\\right) = 1-\\alpha \\] Entonces el intervalo de confianza puede ser expresado como: \\[\\begin{equation} \\boxed{ \\left(\\left(\\overline{Y}-\\overline{X}\\right) - z_{\\alpha/2} \\sqrt{\\frac{\\sigma_X^2}{n}+\\frac{\\sigma_Y^2}{m}}, \\left(\\overline{Y}-\\overline{X}\\right) + z_{\\alpha/2} \\sqrt{\\frac{\\sigma_X^2}{n}+\\frac{\\sigma_Y^2}{m}}\\right) } \\tag{9.3} \\end{equation}\\] 9.2.4 IC diferencia de medias (muestras dependientes) Otro caso común es cuando se desea medir la diferencia de las medias de dos grupos. Donde cada \\(X_i\\) esta distribuida con media \\(\\mu_X\\) y varianza \\(\\sigma_X^2\\), y de una manera análoga \\(Y_i\\) se distribuye \\(\\mu_X\\) y varianza \\(\\sigma_X^2\\). Cuando se asume que las muestras son pareadas se calcula la diferencia entre cada par de valores (\\(X_i\\), \\(Y_i\\)). Para esto, se definer la diferencia \\(D_i = Y_i - X_i\\). Definido de esta forma, D_i se distibuye con media \\(\\mu_D = \\mu_X - \\mu_Y\\) y varianza \\(\\sigma_D^2 = \\sigma_X^2 + \\sigma_Y^2 - 2\\sigma_{XY}\\). En particular, al asumir normalidad: \\(\\overline{Y}-\\overline{X} \\sim N\\left(\\mu_{Y}-\\mu_{X},\\frac{\\sigma_X^2 + \\sigma_Y^2 - 2\\sigma_{XY}}{n}\\right)\\) o visto de otra manera: \\(\\overline{D} \\sim N\\left(\\mu_{D},\\sqrt{\\frac{\\sigma_D^2}{n}}\\right)\\) \\[ Z = \\frac{\\left(\\overline{Y}-\\overline{X} \\right) - \\left(\\mu_{Y}-\\mu_{X}\\right)}{\\sqrt{\\frac{\\sigma_X^2 + \\sigma_Y^2 - 2\\sigma_{XY}}{n}}}\\] Sean \\(-z_{\\alpha/2}\\) y \\(z_{\\alpha_2}\\) puntos críticos, tal que: \\[ P\\left(-z_{\\alpha/2} \\leq Z \\leq z_{\\alpha/2}\\right) = 1-\\alpha \\\\ \\\\ P\\left(-z_{\\alpha/2} \\leq \\frac{\\left(\\overline{Y}-\\overline{X}\\right) -\\left(\\mu_{Y}-\\mu_{X}\\right)}{\\sqrt{\\frac{\\sigma_X^2 + \\sigma_Y^2 - 2\\sigma_{XY}}{n}}} \\leq z_{\\alpha/2}\\right) = 1-\\alpha\\\\ \\\\ P\\left(\\left(\\overline{Y}-\\overline{X}\\right) - z_{\\alpha/2} \\sqrt{\\frac{\\sigma_X^2 + \\sigma_Y^2 - 2\\sigma_{XY}}{n}} \\leq \\mu_Y-\\mu_X \\leq \\left(\\overline{Y}-\\overline{X}\\right) + z_{\\alpha/2} \\sqrt{\\frac{\\sigma_X^2 + \\sigma_Y^2 - 2\\sigma_{XY}}{n}}\\right) = 1-\\alpha \\] \\[\\begin{equation} \\boxed{ \\left(\\left(\\overline{Y}-\\overline{X}\\right) - z_{\\alpha/2} \\sqrt{\\frac{\\sigma_X^2 + \\sigma_Y^2 - 2\\sigma_{XY}}{n}}, \\left(\\overline{Y}-\\overline{X}\\right) + z_{\\alpha/2} \\sqrt{\\frac{\\sigma_X^2 + \\sigma_Y^2 - 2\\sigma_{XY}}{n}}\\right) } \\tag{9.4} \\end{equation}\\] 9.3 Estadístico T - Media (varianza desconocida) Los casos para el estadístico T son muy similares al estadístico Z, solamente que ahora se asume que no se conoce la varianza poblacional y es estimada por la varianza muestral. 9.3.1 IC para la media Si se tienen \\(n\\) datos, donde cada \\(X_i\\) se modela con media \\(\\mu\\) y varianza \\(\\sigma^2\\) desconocida, entonces la varianza se estima con con \\(s^2\\). Por lo tanto tenemos que: \\[T = \\left(\\frac{\\overline{X}-\\mu}{s/\\sqrt{n}}\\right) = \\left(\\frac{\\overline{X}-\\mu}{\\sqrt{\\frac{s^2}{n}}}\\right) \\sim t_{n-1}\\] Sean \\(-t_{(n-1, \\alpha/2)}\\) y \\(t_{(n-1, \\alpha/2)}\\) como puntos críticos, tal que: \\[ P\\left(-t_{(n-1, \\alpha/2)} \\leq T \\leq t_{(n-1, \\alpha/2)}\\right) = 1-\\alpha \\\\ P\\left(-t_{(n-1, \\alpha/2)} \\leq \\frac{\\overline{X}-\\mu}{\\sqrt{\\frac{s^2}{n}}} \\leq t_{(n-1, \\alpha/2)}\\right) = 1-\\alpha\\\\ P\\left(\\overline{X} - t_{(n-1, \\alpha/2)} \\sqrt{\\frac{s^2}{n}} \\leq \\mu \\leq \\overline{X} + t_{(n-1, \\alpha/2)} \\sqrt{\\frac{s^2}{n}}\\right) = 1-\\alpha \\] Entonces el intervalo de confianza puede ser expresado como: \\[\\begin{equation} \\boxed{\\left(\\overline{X} - t_{(n-1, \\alpha/2)} \\frac{s}{\\sqrt{n}}, \\overline{X} + t_{(n-1, \\alpha/2)} \\frac{s}{\\sqrt{n}} \\right)} \\tag{9.5} \\end{equation}\\] 9.3.2 IC para la proporción Nota: para el caso de la distribución \\(Bernoulli(p)\\), al conocer la media se conoce la varianza. Esto es por que la media de la Bernoulli es \\(p\\) y la varianza \\(p(1-p)\\). Por lo tanto la proporción no se puede distribuir como \\(t-student\\). 9.3.3 IC diferencia de medias (muestras independientes) Para la diferencia de medias se tiene no se conoce la varianza de X ni de Y, por lo que se estiman por medio de \\(S_X^2\\) y \\(S_Y^2\\): \\[T = \\frac{\\left(\\overline{Y}-\\overline{X}\\right) -\\left(\\mu_{Y}-\\mu_{X}\\right)}{\\sqrt{\\frac{S_X^2}{n}+\\frac{S_Y^2}{m}}} \\sim t_{n+m-2}\\] Sean \\(-t_{(n+m-2,\\alpha/2)}\\) y \\(t_{(n+m-2, \\alpha/2)}\\) puntos críticos, tal que: \\[ P\\left(-t_{(n+m-2,\\alpha/2)} \\leq T \\leq t_{(n+m-2,\\alpha/2)}\\right) = 1-\\alpha \\\\ \\\\ P\\left(-t_{(n+m-2,\\alpha/2)} \\leq \\frac{\\left(\\overline{Y}-\\overline{X}\\right) -\\left(\\mu_{Y}-\\mu_{X}\\right)}{\\sqrt{\\frac{S_X^2}{n}+\\frac{S_Y^2}{m}}} \\leq t_{(n+m-2,\\alpha/2)}\\right) = 1-\\alpha\\\\ \\\\ P\\left(\\left(\\overline{Y}-\\overline{X}\\right) - t_{(n+m-2,\\alpha/2)} \\sqrt{\\frac{S_X^2}{n}+\\frac{S_Y^2}{m}} \\leq \\mu_Y-\\mu_X \\leq \\left(\\overline{Y}-\\overline{X}\\right) + t_{(n+m-2,\\alpha/2)} \\sqrt{\\frac{S_X^2}{n}+\\frac{S_Y^2}{m}}\\right) = 1-\\alpha \\] Entonces el intervalo de confianza puede ser expresado como: \\[\\begin{equation} \\boxed{ \\left(\\left(\\overline{Y}-\\overline{X}\\right) - t_{(n+m-2, \\alpha/2)} \\sqrt{\\frac{S_X^2}{n}+\\frac{S_Y^2}{m}}, \\left(\\overline{Y}-\\overline{X}\\right) + t_{(n+m-2,\\alpha/2)} \\sqrt{\\frac{S_X^2}{n}+\\frac{S_Y^2}{m}}\\right) } \\tag{9.6} \\end{equation}\\] 9.3.4 IC diferencia de medias (muestras dependientes) Para el caso de muestras independientes, podemos estimar la varianza como sigue: \\[S_D^2 = \\frac{1}{n-1} \\sum_{i = 1}^{n} (D_i-\\bar{D})^2\\] De manera que: \\[ T = \\frac{\\bar{D}- (\\mu_Y-\\mu_X)}{\\sqrt{\\frac{S_D^2}{n}}} \\sim t_{n-1}\\] Es importante notar que los grados de libertad siguen siendo \\(n-1\\). Sean \\(-t_{(n-1, \\alpha/2)}\\) y \\(t_{(n-1,\\alpha\\2)}\\) puntos críticos, tal que: \\[ P\\left(-t_{(n-1,\\alpha/2)} \\leq T \\leq t_{(n-1,\\alpha/2)}\\right) = 1-\\alpha \\\\ \\\\ P\\left(-t_{(n-1,\\alpha/2)} \\leq \\frac{\\overline{D} -\\left(\\mu_{Y}-\\mu_{X}\\right)}{\\sqrt{\\frac{S_D^2}{n}}} \\leq t_{(n-1,\\alpha/2)}\\right) = 1-\\alpha\\\\ \\\\ P\\left(\\overline{D} - t_{(n-1,\\alpha/2)} \\sqrt{\\frac{S_D^2}{n}} \\leq \\mu_Y-\\mu_X \\leq \\overline{D} + t_{(n-1,\\alpha/2)} \\sqrt{\\frac{S_D^2}{n}}\\right) = 1-\\alpha \\] Entonces el intervalo de confianza puede ser expresado como: \\[\\begin{equation} \\boxed{ \\left(\\overline{D} - t_{(n-1, \\alpha/2)} \\sqrt{\\frac{S_D^2}{n}}, \\overline{D} + t_{(n-1,\\alpha/2)} \\sqrt{\\frac{S_D^2}{n}}\\right) } \\tag{9.7} \\end{equation}\\] 9.4 Estadístico J - Varianza Una vez revisado el intervalo de confianza para la media con varianza conocida y desconocida, un paso intuitivo es construir el de la varianza. Como se estudio en clases pasadas, el estimador más común de la varianza es \\(S^2\\). Además se definió el estadistico J con distribución \\(\\chi^2\\). Suponiendo que se cada \\(X_i\\) se distribuye normal y que se tienen n observaciones: \\[J = \\frac{(n-1) s^2}{\\sigma^2} \\sim \\chi_{n-1}^2\\] Entonces, definiendo \\(\\chi_{(n-1, 1-\\alpha/2)}^2\\) y \\(\\chi_{(n-1, \\alpha/2)}^2\\) como puntos criticos: \\[ P\\left(\\chi_{(n-1, 1-\\alpha/2)}^2 \\leq J \\leq \\chi_{(n-1, \\alpha/2)}^2\\right) = 1-\\alpha \\\\ \\\\ P\\left(\\chi_{(n-1, 1-\\alpha/2)}^2 \\leq \\frac{(n-1) s^2}{\\sigma^2} \\leq \\chi_{(n-1, \\alpha/2)}^2\\right) = 1-\\alpha\\\\ \\\\ P\\left( \\frac{(n-1)s^2}{\\chi_{(n-1, \\alpha/2)}^2} \\leq \\sigma^2 \\leq \\frac{(n-1)s^2}{\\chi_{(n-1, 1-\\alpha/2)}^2} \\right) = 1-\\alpha \\] Entonces el intervalo de confianza puede ser expresado como: \\[\\begin{equation} \\boxed{ \\left( \\frac{(n-1)s^2}{\\chi_{(n-1, \\alpha/2)}^2}, \\frac{(n-1)s^2}{\\chi_{(n-1, 1-\\alpha/2)}^2} \\right) } \\tag{9.8} \\end{equation}\\] 9.5 Estadístico F - Cociente de varianzas 9.5.1 IC para cociente de varianzas (muestras independientes) El último estadistico estudiado es la F, usado para el cociente de varianzas. Este es usado en procesos donde se requiere comparar la variabilidad de distintas poblaciones. Para comparar esta variaciones tomamos el supuesto de independencia de las muestras. De clases pasadas sabemos que el estadístico para medir esta variabilidad es la F: \\[ F = \\frac{S_X^2 \\sigma_Y^2}{S_Y^2 \\sigma_X^2} \\sim F_{(n-1, m-1)}\\] Entonces, definiendo \\(F_{(n-1, m-1, 1-\\alpha/2)}\\) y \\(F_{(n-1, m-1, \\alpha/2)}\\) como puntos criticos: \\[ P\\left(F_{(n-1, m-1, 1- \\alpha/2)} \\leq F \\leq F_{(n-1, m-1, \\alpha/2)}\\right) = 1-\\alpha \\\\ \\\\ P\\left(F_{(n-1, m-1, 1- \\alpha/2)} \\leq \\frac{S_X^2 \\sigma_Y^2}{S_Y^2 \\sigma_X^2} \\leq F_{(n-1, m-1, \\alpha/2)}\\right) = 1-\\alpha\\\\ \\\\ P\\left(\\frac{S_Y^2}{S_X^2}F_{(n-1, m-1, 1- \\alpha/2)} \\leq \\frac{\\sigma_Y^2}{ \\sigma_X^2} \\leq \\frac{S_Y^2}{S_X^2} F_{(n-1, m-1, \\alpha/2)}\\right) = 1-\\alpha \\] Entonces el intervalo de confianza puede ser expresado como: \\[\\begin{equation} \\boxed{ \\left(\\frac{S_Y^2}{S_X^2}F_{n-1, m-1, 1- \\alpha/2}, \\frac{S_Y^2}{S_X^2} F_{n-1, m-1, \\alpha/2} \\right) } \\tag{9.9} \\end{equation}\\] 9.6 Tamaño de muestra De los intervalos de confianza mostrados anteriormente, se puede ver que muchos dependen de dos factores: el nivel de confianza \\(1-\\alpha\\) y del tamaño de muestra \\(n\\). Entonces podemos observar que el tamaño de la muestra influye el intervalo que mostramos. Generalmente el \\(n\\) se encuentra en el denominador, por lo que a mayor tamaño de muestra, el intervalo de confianza se hace más reducido. De las primeras clases del curso se introdujo la expresion: \\[|{\\hat{\\theta}- \\theta}| \\leq B\\] Es decir, que tan cerca se encuentra el estimador del parámetro poblacional. La B la definimos coo el error máximo de estimación, tal que: \\[P(|{\\hat{\\theta}- \\theta}| \\leq B) = 1-\\alpha\\] 9.6.1 Tamaño de muestra para la media En el caso de la media, tenemos que el intervalo de confianza para \\(\\mu\\): \\[\\left(\\overline{X} - z_{\\alpha/2} \\frac{\\sigma}{\\sqrt{n}}, \\overline{X} + z_{\\alpha/2} \\frac{\\sigma}{\\sqrt{n}}\\right)\\] Y adecuando la expresión del tamaño de muestra para el caso tenemos que: \\[P(|{{\\overline{X}}- \\mu}| \\leq B) = 1-\\alpha\\] De esta manera, podemos ver \\(B =z_{\\alpha/2} \\frac{\\sigma}{\\sqrt{n}}\\). Despejando \\(n\\) de la expresión tenemos que: \\[ n = \\frac{(z_{\\alpha/2})^2 \\sigma^2}{B^2} \\] 9.6.2 Tamaño de muestra para la proporción En el caso de la proporción, tenemos que el intervalo de confianza para \\(p\\): \\[\\left(\\hat{p} - z_{\\alpha/2} \\sqrt{\\frac{p(1-p)}{n}}, \\hat{p} + z_{\\alpha/2} \\sqrt{\\frac{p(1-p)}{n}} \\right)\\] Y adecuando la expresión del tamaño de muestra para el caso tenemos que: \\[P(|{{\\hat{p}}- p}| \\leq B) = 1-\\alpha\\] De esta manera, podemos ver \\(B =z_{\\alpha/2} \\frac{\\sqrt{\\hat{p}({1-\\hat{p}})}}{\\sqrt{n}}\\). Despejando \\(n\\) de la expresión tenemos que: \\[ n = \\frac{(z_{\\alpha/2})^2 \\hat{p}({1-\\hat{p}})}{B^2} \\] ## Intervalos de confianza de un lado Otra manera de construir intervalos de confianza es tomando unicamente en cuenta una cola. Se dice que un intervalo de confianza es inferior para \\(\\theta\\) si unicamente se proporciona un valor mínimo sin especificar un máximo: \\[(B, \\infty)\\] Por otro lado, se dice que un intervalo de confianza es superior para \\(\\theta\\) si unicamente se proporciona un valor máximo sin especificar un valor mínimo: \\[(-\\infty, A)\\] 9.7 Pruebas de hipótesis Las pruebas de hipótesis se componen de 4 elementos: Hipótesis Nula Hipótesis Alternativa Estadístico de Prueba Región de Rechazo 9.8 Ejemplo de estadístico Z 9.8.1 Diferencia de Medias 9.8.2 Diferencia de Proporciones CDE: 5.2.15 Exercise 9.1 En un estudio reciente, se investigó el efecto de la ingesta de una cierta sustancia en el desarrollo de cáncer pulmonar. Se encontró que de 488 hombres que habían ingerido una baja cantidad de esta sustancia, 14 desarrollaron cáncer pulmonar. En un grupo del mismo tamaño en el que el consumo de esta sustancia era mayor, sólo 5 personas desarrollaron cáncer pulmonar. a) ¿Pruebe si la ingesta alta de esa sustancia reduce el riesgo de cáncer pulmonar en los hombres? Emplee \\(\\alpha = 0.01\\) X: Antes, Y: Después \\(\\hat{p_X} = 14/488 = 0.0287\\) \\(\\hat{p_Y} = 5/488 = 0.0102\\) Hipótesis Nula: \\(H_0: \\mu_X-\\mu_Y = 0\\) Hipótesis Alternativa: \\(H_1: \\mu_X-\\mu_Y&lt; 0\\) Estadístico de Prueba: \\(Z =\\frac{(\\hat{p_X}-\\hat{p_Y}) - (p_X-p_Y)}{\\sqrt{\\frac{(\\hat{p_X})(1-\\hat{p_X})}{n}+\\frac{(\\hat{p_Y})(1-\\hat{p_Y})}{m}}} = \\frac{(0.0287-0.0102) - (0)}{\\sqrt{\\frac{(0.0287)(1-0.0287)}{488}+\\frac{(0.0102)(1-0.0102)}{488}}} = 2.0894\\) Región de Rechazo: \\(RR = \\{Z &lt; Z_{0.01}\\} = \\{Z &lt; qnorm(.01)\\} = \\{Z &lt; -2.3263\\}\\) library(tidyverse) ggplot(data = data.frame(x = c(-3, 3)), aes(x)) + stat_function(fun = dnorm, n = 101, args = list(mean = 0, sd = 1)) + theme_minimal() + labs(x = &quot;mi texto en $&quot;, y = &quot;mi texto en €&quot;, title = &quot;mi titulo&quot;, subtitle = &quot;mi subtitulo&quot;) + geom_vline(xintercept = -2.3263, color = &quot;red&quot;) + geom_rect(aes(xmin=-Inf,xmax=-2.3263,ymin=0,ymax=.5),alpha=0.1,fill=&quot;red&quot;)+ geom_vline(xintercept = -2.0894, color = &quot;orange&quot;) No Rechazamos H_0 Obtenga el nivel de significancia descriptivo o valor p valor-p = \\(pnorm(-2.09) = 0.0183089\\) 9.9 Ejemplo de estadistico T 9.9.1 Diferencia de medias pareada CDE: 5.2.16 Exercise 9.2 Supóngase que, un psicólogo piensa que la edad influye en el coeficiente de inteligencia (IQ). Se toma una muestra aleatoria de 100 personas de mediana edad, de quienes se conoce su IQ a la edad de 16 años y actualmente. De restar, los coeficientes de su juventud de los coeficientes actuales, se obtuvo una diferencia promedio de 6 puntos, con una desviación estándar muestral de 7 puntos. Utilice \\(\\alpha = .01\\) para probar la hipotesis de que el IQ aumenta con la edad. X: IQ a los 16 años Y: IQ actual \\(\\bar{D}: \\bar{Y}-\\bar{X} = 6\\) \\(S_{\\bar{D}} = 7\\) Hipótesis Nula: \\(H_0: \\mu_D = 0\\) Hipótesis Alternativa: \\(H_1: \\mu_D &gt; 0\\) Estadístico de Prueba: \\(T =\\frac{\\bar{D} - \\mu_{\\bar{D}}}{\\sqrt{\\frac{{S_{\\bar{D}^2}}}{n}}} = \\frac{6 - 0}{\\sqrt{\\frac{7^2}{100}}} = 8.5714\\) Región de Rechazo: \\(RR = \\{T &lt; T_{99, 0.01}\\} = \\{T &lt; qt(.99,99)\\} = \\{Z &lt; 2.3646\\}\\) Rechazamos H_0 valor-p = \\(pt(8.5714, 99, lower.tail = F) \\sim 0\\) 9.10 Ejemplo de estadistico J CDE: 5.2.23 Exercise 9.3 La Policía Federal de Caminos desea probar un radar detector de velocidades. Para esto hace circular frente al radar 61 patrullas a una velocidad de 110 Km/h. según su correspondiente velocímetro. De las 61 lecturas del radar obtiene \\(s^2 = 1.69\\). Según la PFC el radar es aceptable si \\(\\sigma &lt;2km/h\\). Adopte el punto de vista que el error grave es comprar el radar cuando en realidad el error de medición está por arriba del límite. a) Formule las hipótesis H0 y H1 apropiadas a este problema. b) Pruebe las hipótesis de a) con un nivel de significancia del 1%. c) De una cota superior para el valor de P. d) Verifique que la decisión de b) concuerda con la estimación de c) Hipótesis Nula: \\(H_0: \\sigma^2 = 4\\) Hipótesis Alternativa: \\(H_1: \\sigma^2 &lt; 4\\) Estadístico de Prueba: \\(J =\\frac{(n-1)S^2}{\\sigma^2} = \\frac{(61-1) 1.69}{4}= 25.35\\) Región de Rechazo: \\(RR = \\{J &lt; J_{0.01,60}\\} = \\{J &lt; qchisq(.01,60)\\} = \\{J &lt; 37.4849\\}\\) Rechazamos H_0 valor-p = \\(pchisq(25.35, 60) \\sim 0\\) 9.11 Ejemplo de estadistico F CDE: 5.2.18 Exercise 9.4 La estabilidad de las mediciones de las características de un producto manufacturado es importante para mantener su calidad. En realidad, es mejor tener, a veces, una pequeña variación en el valor medio de alguna característica importante de un producto y tener una media del proceso un poco fuera del “blanco”, que tener una amplia variación con una media que se ajuste perfectamente a las necesidades. La última situación puede producir un porcentaje mayor de productos defectuosos que la primera. Un fabricante de lámparas eléctricas sospechoso que una de sus líneas de producción estaba fabricando bombillas con una alta variación en su vida útil. Para probar su teoría comparó la vida útil de \\(n = 40\\) lámparas, muestreadas al azar, de la línea que supuestamente no trabajaba bien, y \\(m = 40\\) de la línea que parecía estar “bajo control”. Las medias y las varianzas de las muestras para las dos líneas eran: a) ¿Proporcionan los datos evidencia suficiente para indicar que las bombillas (o focos), producidos por la línea que supuestamente trabaja mal poseen una mayor varianza en la vida útil que las lámparas producidas por la línea que supuestamente estaba bajo control? Utilice \\(\\alpha = 0.05\\). b) Encuentre el nivel de significancia descriptivo que se ha observado para la prueba e interprete su valor. Hipótesis Nula: \\(H_0: \\sigma^2_1 = \\sigma^2_2 \\Rightarrow \\frac{\\sigma^2_1}{\\sigma^2_2} = 1\\) Hipótesis Alternativa: \\(H_1: \\sigma^2_1 &gt; \\sigma^2_2 \\Rightarrow \\frac{\\sigma^2_1}{\\sigma^2_2} &gt; 1\\) Estadístico de Prueba: \\(F =\\frac{S_2^2 \\sigma^2_1}{S_1^2\\sigma^2_2} = \\frac{37000}{92000} = 0.4021739\\) Región de Rechazo: \\(RR = \\{F &gt; F_{0.05,39,39}\\} = \\{F &gt; qf(.95,39,39)\\} = \\{F &gt; 1.704465\\}\\) No Rechazamos H_0 valor-p = \\(pf(0.4021739, 39, 39, lower.tail = F) \\sim 0.997279\\) "]]
